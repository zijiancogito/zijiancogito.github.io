<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Decompiliation | 春秋一语</title>
  <meta name="author" content="Zijian">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="春秋一语"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/journal.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
    <script src="/js/marked.js"></script>
    <script src="/js/comment.js"></script>
    <script src="/js/timeago.min.js"></script>
    <script src="/js/highlight.min.js"></script>
	<script src="/js/spin.min.js"></script>
  
  <!-- analytics -->
  



<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <nav id="main-nav" class="navbar  navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">春秋一语</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      

<!-- title -->
<div class="page-header ">
  <h1 class="archive-title-tag title ">Decompiliation</h1>
</div>

<div class="row page">
  <!-- cols -->
  
  <div class="col-md-9">
	

	  <div id="top_search"></div>

      
         <!-- display as entry -->
	     <div class="mypage">
	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2022-11-04 </div>
			<div class="article-title"><a href="/2022/11/04/angr/" >angr</a></div>						
		</h3>
	


		     <div class="entry">
  <div class="row">
	
	
		<h1 id="Angr学习"><a href="#Angr学习" class="headerlink" title="Angr学习"></a>Angr学习</h1><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="Why-isn’t-symbolic-execution-doing-the-thing-I-want"><a href="#Why-isn’t-symbolic-execution-doing-the-thing-I-want" class="headerlink" title="Why isn’t symbolic execution doing the thing I want?"></a>Why isn’t symbolic execution doing the thing I want?</h3><ul>
<li><p>当遇到错误状态：<code>print(simgr)</code>, <code>print(simgr.errored)</code>.</p>
</li>
<li><p>如果遇到错误状态，并且不能立刻知道哪里错误，可以在crash点调用pdb shell，通过<code>simgr.errored[n].debug()</code>.</p>
</li>
<li><p>当状态没有达到期望的地址：<code>import pprint; pprint.pprint(state.history.descriptions.hardcopy)</code>. 会打印出符号执行引擎在每一步的高级总结和状态历史。可以看到基本块追踪和执行过的前驱。如果使用的是unicorn引擎，可以检查<code>state.history.bbl_addrs.hardcopy</code>来查看每一个unicorn的invocation里执行了哪些基本块。</p>
</li>
<li><p>当状态进入了错误的路径，检查什么约束让它走错了：<code>print(state.solver.constraints)</code>。 如果状态通过了一个分支，可以检查最近的分支通过<code>state.history.events[-1]</code>.</p>
</li>
</ul>
<h3 id="获取angr做了什么的诊断信息"><a href="#获取angr做了什么的诊断信息" class="headerlink" title="获取angr做了什么的诊断信息"></a>获取angr做了什么的诊断信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.getLogger(&#x27;angr&#x27;).setLevel(&#x27;DEBUG&#x27;)</span><br></pre></td></tr></table></figure>
<p><code>WARNING</code>级别是默认的，会输出一些信息，而<code>INFO</code>级别会输出更多信息，比如<code>logging.getLogger(&#39;angr.analyses&#39;).setLevel(&#39;INFO&#39;)</code>会输入所有的分析信息。</p>
<h3 id="序列化angr对象"><a href="#序列化angr对象" class="headerlink" title="序列化angr对象"></a>序列化angr对象</h3><p>使用Pickle。<code>pickle.dumps(obj, -1)</code></p>
<h3 id="angr的CFG和IDA为什么不同"><a href="#angr的CFG和IDA为什么不同" class="headerlink" title="angr的CFG和IDA为什么不同"></a>angr的CFG和IDA为什么不同</h3><p>IDA在函数调用处划分了基本块。使用<code>normalize=True</code>正则化基本块。</p>
<h2 id="Top-Level-Interfaces"><a href="#Top-Level-Interfaces" class="headerlink" title="Top Level Interfaces"></a>Top Level Interfaces</h2><p>首先需要将待分析的二进制加载到一个project中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import angr</span><br><span class="line">proj = angr.Project(&#x27;bin&#x27;)</span><br></pre></td></tr></table></figure><br>Project是angr的控制基础。可以用来分析或者模拟载入的二进制的执行。</p>
<p>将二进制代码映射到虚拟地址空间是复杂的。angr使用了CLE。CLE的结果叫做loader，通过<code>.loader</code>可以获取，现在用它可以看到共享库并可以在加载的地址空间执行基本的查询。</p>
<p>angr中有很多类，他们中的大多数都需要在project的基础上。</p>
<p>angr不推荐将project到处传递，而是使用<code>project.factory</code>，对于一般的常用对象都有便利的接口。</p>
<h4 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h4><p>接口有project.factory.block()，可以从给定地址提取一个基本块。angr以基本块为单位分析代码。会返回一个Block对象，包含很多有趣的信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block =  proj.factory.block(proj.entry)</span><br></pre></td></tr></table></figure></p>
<h4 id="States"><a href="#States" class="headerlink" title="States"></a>States</h4><p>Project对象只是程序的初始镜像。当开始模拟执行时，会用到一个特殊的对象simulated program state <code>SimState</code>.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = proj.factory.entry_state()</span><br></pre></td></tr></table></figure><br>SimState包含了程序的内存，寄存器，文件系统数据，等各种会在执行过程中发生变化的“live data”。使用<code>state.regs</code>和<code>state.mem</code>可以访问当前状态的寄存器和内存。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state.regs.rip</span><br><span class="line">state.regs.rax</span><br><span class="line">state.mem[proj.entry].int.resolved</span><br></pre></td></tr></table></figure><br>这些不是Python的int变量，而是位向量<em>bitvectors</em>。Python的整形和CPU中的数据没有相同的语义，因此使用位向量来表示CPU中的数据。每一个位向量都有一个<code>.length</code>属性来描述比特的宽度。</p>
<p>转换Python整数到位向量的方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bv = state.solver.BVV(0x1234, 32)  # create a 32-bit-wide bitvector with value 0x1234</span><br><span class="line">state.solver.eval(bv)  # convert to Python int</span><br></pre></td></tr></table></figure><br>位向量可以存回寄存器和内存中，或者直接将一个python整数存储，它会被转换搭配合适大小的位向量<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state.regs.rsi = state.solver.BVV(3, 64)</span><br><span class="line">state.mem[0x1000].long = 4  # directly store python ints to memory</span><br></pre></td></tr></table></figure></p>
<p><code>mem</code>接口可能有点困惑，因为它使用了一些非常多的python magic。简短地介绍一下它怎么用：</p>
<ul>
<li>使用array[index]来指定一个地址</li>
<li>使用<code>.&lt;type&gt;</code>来指定这个内存必须用<type>类型解释，比如char，short等</li>
<li>存一个value进去，不管是一个bitvector还是一个python int</li>
<li>使用<code>.resolved</code> to get the value as a bitvector</li>
<li>Use <code>.concrete</code>to get the value as a Python int</li>
</ul>
<p>如果在读取寄存器时遇到了非常奇怪的值，比如<code>&lt;BV64 reg_48_11_64&#123;UNINITIALIZED&#125;&gt;</code>,这依然是一个64位的位向量，但是不包含具体的数值。但是它有一个名字！叫做<strong>符号</strong>。是符号执行时需要用到的。</p>
<h4 id="Simulation-Managers"><a href="#Simulation-Managers" class="headerlink" title="Simulation Managers"></a>Simulation Managers</h4><p>如果状态能够让我们用来表示一个给定时间点的程序，那么就一定能够获取到下一个时间点的程序。模拟管理器就是angr进行执行，模拟的一个接口。简短介绍一下，如何将先前创建的状态向前tick几个基本块。</p>
<p>首先，创建了一个模拟管理器。构造器需要输入一个状态或者一个状态列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">simgr = proj.factory.simulation_manager(state)</span><br><span class="line">simgr.active</span><br></pre></td></tr></table></figure>
<p>模拟管理器可能包含数个状态的存储空间（stashes）。默认的stash，<code>active</code>，是使用我们传进去的状态初始化的。可以通过<code>simgr.active[0]</code>来查看更多的状态。</p>
<p>现在。。。准备，开始进行执行<br><code>simgr.step()</code></p>
<p>执行了一个基本块之后，可以再次查看一下active stash，现在它已经被更新，但是不会改变我们的初始状态。SimState对象在执行对称中是不可修改的。可以安全的使用一个状态作为多轮执行的“base”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; simgr.active</span><br><span class="line">[&lt;SimState @ 0x1020300&gt;]</span><br><span class="line">&gt;&gt;&gt; simgr.active[0].regs.rip	# new and exciting!</span><br><span class="line">&lt;BV64 0x1020300&gt;</span><br><span class="line">&gt;&gt;&gt; state.regs.rip	# still the same!</span><br><span class="line">&lt;BV64 0x401670&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Analyses"><a href="#Analyses" class="headerlink" title="Analyses"></a>Analyses</h4><p>angr有一些内置的分析，可以用来从程序中提取一些有趣的信息。如果想要知道每一个怎么使用需要看API文档。<br>简单的快速获取控制流图的例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proj = angr.Project(&#x27;test&#x27;, auto_load_libs=False)</span><br><span class="line">cfg = proj.analyses.CFGFast()</span><br><span class="line">cfg.graph</span><br><span class="line">len(cfg.graph.nodes())</span><br><span class="line">entry_node = cfg.get_any_node(proj.entry)</span><br><span class="line">len(list(cfg.graph.successors(entry_node)))</span><br></pre></td></tr></table></figure></p>
<h2 id="Loading-a-Binary"><a href="#Loading-a-Binary" class="headerlink" title="Loading a Binary"></a>Loading a Binary</h2><p>CLE Loads Everything！</p>
<h4 id="Loaded-Objects"><a href="#Loaded-Objects" class="headerlink" title="Loaded Objects"></a>Loaded Objects</h4><p>CLE加载器 <code>cle.loader</code> 代表加载的二进制对象，加载和映射的内存空间的集合体。每一个二进制对象被对应文件类型的加载器后端加载。比如<code>cle.ELF</code>。</p>
<p>内存中也有一些对象是没有对应任何加载的二进制的。例如，用来提供本地现成存储支持的对象。和用来提供未解决的符号的外部对象。</p>
<p>通过<code>loader.all_objects</code>可以获取到CLE加载的所有对象以及更多目标类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proj.loader.all_objects</span><br><span class="line">proj.loader.main_object</span><br><span class="line">proj.loader.shared_objects</span><br><span class="line">proj.loader.all_elf_objects</span><br><span class="line">proj.loader.extern_object</span><br><span class="line">proj.loader.kernel_object</span><br><span class="line">proj.loader.find_object_containing(0x400000) # get a reference to an object gitven **an address *in* it**</span><br></pre></td></tr></table></figure>
<p>可以直接和对象交互来获取其中的metadata</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = proj.loader.main_object</span><br><span class="line">obj.entry</span><br><span class="line">obj.min_addr, obj.max_addr</span><br></pre></td></tr></table></figure>
<h4 id="Symbols-and-Relocations"><a href="#Symbols-and-Relocations" class="headerlink" title="Symbols and Relocations"></a>Symbols and Relocations</h4><p>符号是一个地址对应的名字。最简单的使用CLE获取符号的方式是<code>loader.find_symbol</code>。它可以输入一个名字或者一个地址，然后返回一个Symbol对象。</p>
<p>符号最有用的属性是它的<strong>名字，所有者，地址</strong>。但是地址可能是有歧义的。符号对象有三种方式来记录他的地址：</p>
<ul>
<li><code>.rebased_addr</code> 是它在全局地址空间中的地址</li>
<li><code>.linked_addr</code> 是他对于二进制prelinked的基地址的相对地址<br>_ <code>.relative_addr</code> 是相对于整个object的基址的相对地址。</li>
</ul>
<p>除了提供调试信息之外，符号也可以用来支持动态链接。libc提供了strcmp symbol，很多二进制都依赖它。如果询问CLE，获取strcmp符号，他将会返回它是<em>import symbol</em>。它没有实际的地址，但是会提供一个指向符号的reference从而解析它 <code>.resolvedby</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strcmp.is_export</span><br><span class="line">strcmp.is_import</span><br><span class="line">&gt;&gt;&gt; strcmp.resolvedby</span><br><span class="line">&lt;Symbol &quot;strcmp&quot; in libc.so.6 at 0x1089cd0&gt;</span><br></pre></td></tr></table></figure></p>
<p>imports和exports的link是由<em>relocations</em>处理的。relocation指当你把[import]和export的symbol匹配时，需要将export的地址写到[location]中，格式是[format]。使用<code>obj.relocs</code>可以看到一个对象(<code>Relocation</code>)的完整列表。使用<code>obj.imports</code>可以将符号名字映射到Relocation上。而对于export symbol没有对应的列表。</p>
<p>重定位对应的import symbol可以通过<code>.symbol</code>访问。relocation的地址将会写入到访问中，通过Symbol的任何地址标识，你可以通过访问<code>.owner</code>来获取到对象的引用。</p>
<p>如果import不能被解析成任何export，可能是因为共享库找不到，CLE将会自动更新外部对象<code>loader.extern_obj</code>来声明，它提供了符号作为export。</p>
<h3 id="Loading-Options"><a href="#Loading-Options" class="headerlink" title="Loading Options"></a>Loading Options</h3><p>如果在使用<code>angr.Project</code>加载东西时，想要向<code>cle.Loader</code>中传递一个选项，只需要直接向Project的构造器中传递关键词，然后它就会传递到CLE中，可以看CLE的API文档。</p>
<p>基本的选项有auto_load_libs, froce_load_libs, except_missing_libs, skip_libs.</p>
<h4 id="Pre-Binary-Options"><a href="#Pre-Binary-Options" class="headerlink" title="Pre-Binary Options"></a>Pre-Binary Options</h4><p>如果想要针对特定的二进制对象给特定的选项，CLE也可以实现。参数main_opts和lib_opts可以实现。<code>main_opts</code>是从选项名称到选项值的映射，<code>lib_opts</code>是从库名称到字典（选项名称-&gt;选项值）的映射。</p>
<ul>
<li>backend：使用的后端是哪种，class还是name</li>
<li>base_addr：基址</li>
<li>entry_point：入口点</li>
<li>arch：架构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; angr.Project(&#x27;examples/fauxware/fauxware&#x27;, main_opts=&#123;&#x27;backend&#x27;: &#x27;blob&#x27;, &#x27;arch&#x27;: &#x27;i386&#x27;&#125;, lib_opts=&#123;&#x27;libc.so.6&#x27;: &#123;&#x27;backend&#x27;: &#x27;elf&#x27;&#125;&#125;)</span><br><span class="line">&lt;Project examples/fauxware/fauxware&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Symbolic-Function-Summaries"><a href="#Symbolic-Function-Summaries" class="headerlink" title="Symbolic Function Summaries"></a>Symbolic Function Summaries</h4><p>Project试图使用符号总结symbolic summaries（SimProcedures）来代理对库函数的调用。这些内置的过程可以通过<code>angr.SIM_PROCEDURES</code>获取</p>
<h4 id="Hooking"><a href="#Hooking" class="headerlink" title="Hooking"></a>Hooking</h4><p>angr使用python summary替代一个库代码的方法叫hooking。在模拟的过程中，每一步，angr都检查当前的地址是否被hook，如果是，就运行hook而不是运行那个地址的二进制代码。Hook的方法是使用API <code>proj.hook(addr, hook)</code>，其中hook是一个SimProcedure。可以使用<code>.is_hooked</code>和<code>.unhook</code>,<code>.hooked_by</code>管理项目中的钩子。</p>
<p>使用API hook一个地址的替代方法是，使用自己的off-the-cuff函数，通过使用proj.hook(addr)作为函数修饰。如果这么做了，可以选择制定一个length<br>关键字来使得执行跳转一定的字节，在hook完成之后。</p>
<p>另外，还可以使用<code>proj.hook_symbol(name, hook)</code>，提供符号的名字来hook符号所活跃的地址。</p>
<h2 id="Solver-Engine"><a href="#Solver-Engine" class="headerlink" title="Solver Engine"></a>Solver Engine</h2><p>angr的强大之处不仅在于模拟器，而是可以进行符号执行。使用符号表示一个变量，并且在对应变量上执行算术操作会生成一个操作的树（叫AST）。AST可以被翻译称SMT求解器的约束，例如Z3，为了回答问题：给定这个操作序列的输出，输入应该是什么样的。</p>
<h3 id="Working-with-Bitvectors"><a href="#Working-with-Bitvectors" class="headerlink" title="Working with Bitvectors"></a>Working with Bitvectors</h3><p>位向量是一个比特序列。可以有任意的比特序列，称之为位向量，并且在他们之上做数学操作。</p>
<p>对不同长度的位向量进行操作会触发类型错误。但是可以对位向量进行extend到合适的长度。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weird_nine = state.solver.BVV(9,27)</span><br><span class="line">weird_nine.zero_extend(64, 27)</span><br></pre></td></tr></table></figure></p>
<p><code>zero_extend</code>会在位向量左侧添加给定数量的0。<code>sign_extend</code>会使用最高位的比特重复。</p>
<p>创建符号变量<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = state.solve.BVS(&quot;x&quot;, 64)</span><br><span class="line">y = state.solve.BVS(&quot;y&quot;, 64)</span><br></pre></td></tr></table></figure></p>
<p>x和y现在是符号变量。你提供的名字后面都会自动被附加后缀计数器。你可以随便对他们做算术运算，但是不会得到一个值，而是会得到一个AST。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x + one</span><br><span class="line">&lt;BV64 x_9_64 + 0x1&gt;</span><br><span class="line">&gt;&gt;&gt; x - y</span><br><span class="line">&lt;BV64 x_9_64 - y_10_64&gt;</span><br></pre></td></tr></table></figure><br>x,y和one也都是AST，任何位向量都是一个操作树，即使这个树的深度只有1。为了理解这一点，我们来学习一下如何处理AST。</p>
<p>每个AST都有一个<code>.op</code>和<code>.args</code>。op是一个字符串，代表执行的操作，args是该操作需要输入的值。除非操作是BVV或BVS等少数，参数全部是其他AST，树的终止节点是BVV或者BVS。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tree = (x + 1) / (y + 2)</span><br><span class="line">&gt;&gt;&gt; tree</span><br><span class="line">&lt;BV64 (x_9_64 + 0x1) / (y_10_64 + 0x2)&gt;</span><br><span class="line">&gt;&gt;&gt; tree.op</span><br><span class="line">&#x27;___floordiv__&#x27;</span><br><span class="line">&gt;&gt;&gt; tree.args</span><br><span class="line">(&lt;BV64 x_9_64 + 0x1&gt;, &lt;BV64 y_10_64 + 0x2&gt;)</span><br><span class="line">&gt;&gt;&gt; tree.args[0].op</span><br><span class="line">&#x27;__add__&#x27;</span><br><span class="line">&gt;&gt;&gt; tree.args[0].args</span><br><span class="line">(&lt;BV64 x_9_64&gt;, &lt;BV64 0x1&gt;)</span><br><span class="line">&gt;&gt;&gt; tree.args[0].args[1].op</span><br><span class="line">&#x27;BVV&#x27;</span><br><span class="line">&gt;&gt;&gt; tree.args[0].args[1].args</span><br><span class="line">(1, 64)</span><br></pre></td></tr></table></figure></p>
<p>之后的介绍中，我们会使用“bitvector”来代表任何最顶层操作会产生位向量的AST。也有一些其他数据类型用AST表示，包括浮点数和布尔值。</p>
<h3 id="Symbolic-Constraints"><a href="#Symbolic-Constraints" class="headerlink" title="Symbolic Constraints"></a>Symbolic Constraints</h3><p>对任何两个相似类型的AST进行的比较操作会生成另一个AST，不是bitvector而是布尔符号<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x == 1</span><br><span class="line">&lt;Bool x_9_64 == 0x1&gt;</span><br><span class="line">&gt;&gt;&gt; one_hunderd &gt; 5</span><br><span class="line">&lt;Bool True&gt;</span><br></pre></td></tr></table></figure></p>
<p>在使用angr的时候不应该直接比较两个变量，在if或者while语句中，因为结果可能不会有一个具体的真值。即使有真值<code>if one &gt; one_hundred</code>也会引发异常。相反，应该使用<code>solve.is_true</code>和<code>solver.is_false</code>，来test具体的真假而不使用进行约束求解。</p>
<h3 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h3><p>可以将一个符号布尔看作一个符号变量的合法值的断言通过将它作为约束加到状态上。然后可以通过查询符号表达式的evaluation来获取符号变量的合法值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; state.solver.add(x &gt; y)</span><br><span class="line">&gt;&gt;&gt; state.solver.add(y &gt; 2)</span><br><span class="line">&gt;&gt;&gt; state.solver.add(10 &gt; x)</span><br><span class="line">&gt;&gt;&gt; state.solver.eval(x)</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; state = proj.factory.entry_state()</span><br><span class="line">&gt;&gt;&gt; input = state.solver.BVS(&#x27;input&#x27;, 64)</span><br><span class="line">&gt;&gt;&gt; operation = (((input + 4) * 3) &gt;&gt; 1) + input</span><br><span class="line">&gt;&gt;&gt; output = 200</span><br><span class="line">&gt;&gt;&gt; state.solver.add(operation == output)</span><br><span class="line">&gt;&gt;&gt; state.solver.eval(input)</span><br><span class="line">0x3333333333...</span><br></pre></td></tr></table></figure>
<p>可以通过<code>state.satisfiable()</code>来判断一个状态的可满足性。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; state.solver.add(input &lt; 2**32)</span><br><span class="line">&gt;&gt;&gt; state.satifisable()</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>可以evaluate更复杂的表达式<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; state = proj.factory.entry_state()</span><br><span class="line">&gt;&gt;&gt; state.solver.add(x - y &gt;= 4)</span><br><span class="line">&gt;&gt;&gt; state.solver.add(y &gt; 0)</span><br><span class="line">&gt;&gt;&gt; state.solver.eval(x)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; state.solver.eval(y)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; state.solver.eval(x + y)</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>可以看到eval是一个常用的将bitvector转换成python primitive的方法，同时保留了状态的完整性。这就是我们使用eval将具体的位向量转换成python int的方法。</p>
<p>x和y可以被用在新状态中，尽管它已经被用在旧的状态中，变量不被绑定在任何状态中，是自由存在的！</p>
<h3 id="Floating-point-numbers"><a href="#Floating-point-numbers" class="headerlink" title="Floating point numbers"></a>Floating point numbers</h3><p>除了宽度之外，浮点数还有一个sort。可以使用FPV和FPS创建浮点符号。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; state = proj.factory.entry_state()</span><br><span class="line">&gt;&gt;&gt; a = state.solver.FPV(3.2, state.solver.fp.FSORT_DOUBLE)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;FP64 FPV(3.2, DOUBLE)&gt;</span><br><span class="line">&gt;&gt;&gt; a + b</span><br><span class="line">&lt;FP64 fpAdd(&#x27;RNE&#x27;, FPV(3.2, DOUBLE), FPS(&#x27;FP_b_0_64&#x27;, DOUBLE))&gt;</span><br><span class="line">&gt;&gt;&gt; a + 4.4</span><br><span class="line">&lt;FP64 FPV(7.6000000000000005, DOUBLE)&gt;</span><br><span class="line">&gt;&gt;&gt; b + 2 &lt; 0</span><br><span class="line">&lt;Bool fpLT(fpAdd(&#x27;RNE&#x27;, FPS(&#x27;FP_b_0_64&#x27;, DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="More-Solving-Methods"><a href="#More-Solving-Methods" class="headerlink" title="More Solving Methods"></a>More Solving Methods</h3><p>eval可以给表达式一个可能的解，但是如果需要更多的解？<br>更多求解方式如下</p>
<ul>
<li>solver.eval(expression)会给出表达式一个可能的解</li>
<li>solver.eval_one(expression)会给出表达式的解，并且如果有超过一个解会抛出错误</li>
<li>solver.eval_upto(expression, n)会给出表达式的n个解，如果解的总数小于n会给出小于n个解</li>
<li>solver.eval_atleast(expression, n)会给出给定表达式的n个解，如果可能的解的个数小于n会抛出错误</li>
<li>solver.eval_exact(expression, n)会给出表达式的n个解，如果可能的解大于或者小于n会抛出错误</li>
<li>solver.min(expression)会给出表达式最小可能的解</li>
<li>solver.max(expression)会给出表达式最大可能的解</li>
</ul>
<p>除此之外，所有这些方法都可以传入这些参数：</p>
<ul>
<li>extra_constraints可以传入一组约束，这些约束在eval的过程中会被考虑到，但是不会加入状态中</li>
<li>cast_to可以传入一个数据类型，将结果进行强制转换。目前，只支持int和byts。例如，<code>state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=bytes)</code>将会返回会<code>b&#39;ABCD&#39;</code>。</li>
</ul>
<h2 id="Program-State"><a href="#Program-State" class="headerlink" title="Program State"></a>Program State</h2><p>任何的bitvector类型的AST都可以被存储在寄存器或者内存中。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; state.regs.rbp = state.regs.rsp</span><br><span class="line">&gt;&gt;&gt; state.mem[0x1000].uint64_t = state.regs.rdx</span><br><span class="line">&gt;&gt;&gt; state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved</span><br><span class="line">&gt;&gt;&gt; state.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved</span><br></pre></td></tr></table></figure></p>
<h3 id="Basic-Execution"><a href="#Basic-Execution" class="headerlink" title="Basic Execution"></a>Basic Execution</h3><p>符号执行是怎么工作的: state.step()。<br>这个方法会执行一部的符号执行，并返回SimSuccessors对象。符号执行可以产生多个继承状态。目前，只关注对象的<code>.successors</code>属性，他是一个给定步数的包含所有后继的列表。</p>
<p>angr符号执行的过程是获取程序中的指令的操作，然后根据它改变SimState。当到达<code>if (x &gt; 4)</code>这样的语句时，会执行x&gt;4，结果是<Bool x_32_1 > 4&gt;.</p>
<p>angr保留true和false两个分支。会产生两个独立的后继状态。如果是true，就将x&gt;4加入到约束中，反之，将!(x&gt;4)加入到约束中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; proj = angr.Project(&#x27;examples/fauxware/fauxware&#x27;)</span><br><span class="line">&gt;&gt;&gt; state = proj.factory.entry_state(stdin=angr.SimFile)  # ignore that argument for now - we&#x27;re disabling a more complicated default setup for the sake of education</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     succ = state.step()</span><br><span class="line">...     if len(succ.successors) == 2:</span><br><span class="line">...         break</span><br><span class="line">...     state = succ.successors[0]</span><br><span class="line">​</span><br><span class="line">&gt;&gt;&gt; state1, state2 = succ.successors</span><br><span class="line">&gt;&gt;&gt; state1</span><br><span class="line">&lt;SimState @ 0x400629&gt;</span><br><span class="line">&gt;&gt;&gt; state2</span><br><span class="line">&lt;SimState @ 0x400699&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>state.posix.stdin.load(0, state.posix.stdin.size)</code>来获取从stdin读入的bitvector。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; input_data = state1.posix.stdin.load(0, state1.posix.stdin.size)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; state1.solver.eval(input_data, cast_to=bytes)</span><br><span class="line">b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00\x00\x00&#x27;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; state2.solver.eval(input_data, cast_to=bytes)</span><br><span class="line">b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x00\x80N\x00\x00 \x00\x00\x00\x00&#x27;</span><br></pre></td></tr></table></figure>
<p>为了执行到state1路径，需要给定字符串SOSNEAKY。为了执行到state2路径，需要给其他字符串。</p>
<h3 id="State-Presets"><a href="#State-Presets" class="headerlink" title="State Presets"></a>State Presets</h3><p>创建状态的方式：</p>
<ul>
<li><code>.blank_state()</code>构建了一个空白状态，访问他时会返回一个没有约束的符号值</li>
<li><code>.entry_state()</code>构建了一个main二进制的入口点状态</li>
<li><code>.full_init_state()</code>构建了一个在入口点之前需要执行的状态，例如共享库构造或者初始化。完成之后将跳转到入口点。</li>
<li><strong><code>.call_state()</code>构造一个执行给定函数的状态。</strong></li>
</ul>
<p>可以通过下面这些参数定制状态：</p>
<ul>
<li>addr可以指定开始的地址</li>
<li>如果需要传递命令行参数或环境，可以通过args参数和通过env传递环境变量的目录到entry_state和full_init_state。这些结构中的值可以是字符串或者位向量，并且会作为参数和环境序列化为状态传递到模拟执行中。默认的args是空列表。</li>
<li>如果想要argc变成符号，需要传入一个符号位向量argc到entry_state和full_init_state中。如果加了这个符号，就需要加一个约束，保证argv的个数不超过argc</li>
<li>使用call state时，用<code>.call_state(addr, arg1, arg2, ...)</code>，其中addr是想要调用的函数的地址，argN是那个函数的第n个参数，可以是python integer，string或 array， bitvector。如果想要分配内存，传递一个对象的指针进去，需要用PointerWrapper打包，例如<code>angr.PointerWrapper(&quot;point to me!&quot;)</code>。这个api的结果可能是不可预测的。</li>
<li>为了通过call_state指定调用约定，可以传递一个SimCC实例作为cc参数。</li>
</ul>
<p>更多的构造器和选项需要看project.factory object (an AngrObjectFactory)文档</p>
<h3 id="Low-level-interface-for-memory"><a href="#Low-level-interface-for-memory" class="headerlink" title="Low level interface for memory"></a>Low level interface for memory</h3><p>state.mem接口可以很方便地从内存中加载特定类型的数据，但是如过想要加载或者存储原始数据，从一个给定的内存范围，是处理不了的。使用state.memory的.load(addr, size)和.store(addr, val)方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; s = proj.factory.blank_state()</span><br><span class="line">&gt;&gt;&gt; s.memory.store(0x4000, s.solver.BVV(0x0123456789abcdef0123456789abcdef, 128))</span><br><span class="line">&gt;&gt;&gt; s.memory.load(0x4004, 6) # load-size is in bytes</span><br><span class="line">&lt;BV48 0x89abcdef0123&gt;</span><br></pre></td></tr></table></figure><br>可以看到数据是以大端序的风格存储的。如果想要交换字节，可以用关键字endness。endness必须是Endness枚举类型的成员在archinfo包中。待分析程序的endness可以通过arch.memory_endness获取，例如state.arch.memory_endness<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import archinfo</span><br><span class="line">&gt;&gt;&gt; s.memory.load(0x4000, 4, endness=archinfo.Endness.LE)</span><br><span class="line">&lt;BV32 0x67452301&gt;</span><br></pre></td></tr></table></figure><br>还有寄存器访问的低级接口state.registers。他使用和state.memory相同的API。</p>
<h3 id="State-Options"><a href="#State-Options" class="headerlink" title="State Options"></a>State Options</h3><p>对每一个SimState对象，都有一个他所有可能的选项state.options集合。每个选项控制着执行引擎的行为。可以通过angr.options获取所有可以加入到状态中的合法选项。合法选项都以大写字母命名，还有一些常用的将对象绑定在一起的选项用小写字母命名。</p>
<p>当使用构造器创建一个SimState时，可以传递关键参数add_options和remove_options来改变默认的初始参数集合<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Example: enable lazy solves, an option that causes state satisfiability to be checked as infrequently as possible.</span><br><span class="line"># This change to the settings will be propagated to all successor states created from this state after this line.</span><br><span class="line">&gt;&gt;&gt; s.options.add(angr.options.LAZY_SOLVES)</span><br><span class="line"></span><br><span class="line"># Create a new state with lazy solves enabled</span><br><span class="line">&gt;&gt;&gt; s = proj.factory.entry_state(add_options=&#123;angr.options.LAZY_SOLVES&#125;)</span><br><span class="line"></span><br><span class="line"># Create a new state without simplification options enabled</span><br><span class="line">&gt;&gt;&gt; s = proj.factory.entry_state(remove_options=angr.options.simplification)</span><br></pre></td></tr></table></figure></p>
<h3 id="State-Plugins"><a href="#State-Plugins" class="headerlink" title="State Plugins"></a>State Plugins</h3><p>存储在SimState中的内容都是以plugin的形式附加在状态中的。几乎状态中的所有属性都是plugin，包括memory, registers，mem，regs，solver等。这种设计使得实现新的数据存储很容易。</p>
<h4 id="The-globals-plugin"><a href="#The-globals-plugin" class="headerlink" title="The globals plugin"></a>The globals plugin</h4><p>state.globals是一个非常简单的插件，他实现了标准的python字典，可以在状态中随意存储数据</p>
<h4 id="The-history-plugin"><a href="#The-history-plugin" class="headerlink" title="The history plugin"></a>The history plugin</h4><p>state.history是很重要的插件，存储了一个状态在执行中经历的路径上的历史数据。是一个包含多个历史节点的链表，每一个都表示了一轮执行，可以通过<code>state.history.parent.parent</code>对他进行遍历。</p>
<p>为了更方便的使用这个结构，history还提供了一些遍历特定值的方式。这些值存储为<code>history.recent_NAME</code>，迭代器是history.NAME。例如，</p>
<ul>
<li><code>for addr in state.history.bbl_addrs: print hex(addr)</code>会输出基本块地址trace，</li>
<li>而state.history.recent_bbl_addrs是最近几步执行的基本块列表</li>
<li>state.history.parent.recent_bbl_addrs前一步执行的基本块的列表</li>
<li>.hardcopy可以快速获取这些值的列表，例如state.history.bbl_addrs.hardcopy。</li>
</ul>
<p>总之，迭代器可以实现基于检索的访问</p>
<p>下面列出一些历史中存储的值</p>
<ul>
<li>history.descriptions是一个字符串列表，描述了状态的每一轮执行</li>
<li>history.bbl_addrs是一个状态执行的基本块地址列表。每一轮的执行中可能有多个，并不是所有的地址都在二进制中对应，有一些地址可能是SimProcedures hook的地方。</li>
<li>history.jumpkinds是状态历史中每一个控制转移的方向，是VEX 枚举字符串类型</li>
<li>history.jump_guards 是描述状态遇到的所有分支的conditions</li>
<li>history.events是执行过程中发生的“有趣事件”的语义列表，比如，符号跳转条件，程序弹出了一个提示窗口，程序执行终止并返回一个exit code。</li>
<li>history.actions通常是空的，除非你在状态中加入了angr.options.refs，它用来记录所有的内存，寄存器，临时值</li>
</ul>
<h4 id="The-callstack-plugin"><a href="#The-callstack-plugin" class="headerlink" title="The callstack plugin"></a>The callstack plugin</h4><p>angr会追踪模拟过程中的调用栈。调用栈也是一个节点的链表，但是不提供迭代器。可以直接通过state.callstack迭代来获取每一个活跃的栈帧，以从新到旧的顺序。如果只想要栈顶的，那就是state.callstack</p>
<ul>
<li>callstack.func_addr是正在执行的函数的地址</li>
<li>callstack.call_site_addr是调用当前函数的基本块的地址</li>
<li>callstack.stack_ptr是从当前函数的开头的站指针的值</li>
<li>callstack.ret_addr是当前函数所返回到的地址。</li>
</ul>
<h3 id="More-about-I-O-Files-file-systems-and-network-sockets"><a href="#More-about-I-O-Files-file-systems-and-network-sockets" class="headerlink" title="More about I/O: Files, file systems, and network sockets"></a>More about I/O: Files, file systems, and network sockets</h3><p>看Working with File System，Sockets， and Pipes章节</p>
<h2 id="Simulation-Managers-1"><a href="#Simulation-Managers-1" class="headerlink" title="Simulation Managers"></a>Simulation Managers</h2><p>angr中最重要的控制接口是模拟管理器，</p>
<h3 id="Stepping"><a href="#Stepping" class="headerlink" title="Stepping"></a>Stepping</h3><p>模拟管理器最基本的能力就是将所有的状态向前推进一个基本块，在给定的stash中。使用.step()</p>
<p>.step()和.run()</p>
<h3 id="Stash-Management"><a href="#Stash-Management" class="headerlink" title="Stash Management"></a>Stash Management</h3><p>理解：stash就是一个列表，存放一些具有相同特征的状态，比如用一些filter过滤出来的，接下来要执行的等。</p>
<p>stash之间转换状态使用.move()，参数是from_stash, to_stash, filter_func（可选的，默认的是move所有）</p>
<p>每个stash是一个列表，可以索引或者迭代访问列表中的每一个合法状态。还有一些其他方式访问，比如如果使用stash的名字，前缀加one_，可以获取到stash的第一个状态，如果前缀加mp_，可以获取mulpyplexed版本的stash</p>
<h3 id="Stash-types"><a href="#Stash-types" class="headerlink" title="Stash types"></a>Stash types</h3><ul>
<li>active: 这个stash包含了默认要step大片的状态，除非指定了其他的stash</li>
<li>deadended：会进入到deadended stash的状态，当程序由于某些原因不能继续执行，比如没有合法的指令，不合法的指令指针，所有后继都不能满足</li>
<li>pruned：当使用LAZY_SOLVES，</li>
<li>unconstrained</li>
<li>unsat</li>
</ul>
<h3 id="Simple-Exploration"><a href="#Simple-Exploration" class="headerlink" title="Simple Exploration"></a>Simple Exploration</h3><p>找到到达特定地址的状态，使用.explore()方法。使用参数find,执行将会运行直到找到和find匹配的条件。结果会在found stash中<br>也可以指定一个avoid条件，结果会存在avoided stash中<br>num_find参数控制着的个数，默认是1</p>
<h3 id="Exploration-Techniques"><a href="#Exploration-Techniques" class="headerlink" title="Exploration Techniques"></a>Exploration Techniques</h3><p>使用探索技术调用simgr.use_technique(tech)，其中tech是一个ExplorationTechnique的子类实例，angr.exploration_techniques可以看到angr内置的探索技术</p>
<h2 id="Execution-Engines"><a href="#Execution-Engines" class="headerlink" title="Execution Engines"></a>Execution Engines</h2><h3 id="Breakpoints"><a href="#Breakpoints" class="headerlink" title="Breakpoints"></a>Breakpoints</h3><p>可以设置在执行到某一类操作时停止，比如内存读</p>
<h2 id="Analyses-1"><a href="#Analyses-1" class="headerlink" title="Analyses"></a>Analyses</h2><p>内置的分析</p>
<h1 id="Claripy"><a href="#Claripy" class="headerlink" title="Claripy"></a>Claripy</h1><p>是angr的求解引擎。<br>Claripy AST会提供一种可以和具体和符号的表达式进行交互的方式。</p>
<p>前端提供不同的参数来eval这些表达式。例如FullFrontend使用SMT后端求解符号表达式。LightFrontend使用抽象数据域后端。</p>
<h2 id="Claripy-ASTs"><a href="#Claripy-ASTs" class="headerlink" title="Claripy ASTs"></a>Claripy ASTs</h2><p>现在claripy支持下面这些类型的AST： BV（bitvector），FP（float point），Bool（Boolean operation）</p>
<h2 id="Claripy-Backends"><a href="#Claripy-Backends" class="headerlink" title="Claripy Backends"></a>Claripy Backends</h2><p>claripy对外界暴露的接口是AST</p>

	
	</div>
  <a type="button" href="/2022/11/04/angr/#more" class="btn btn-default more">阅读此文</a>
</div>

	       
	     </div>
	     <div>
	       <center>
	         <div class="pagination">
<ul class="pagination">
	 
</ul>
</div>

	       </center>
	     </div>	
      

</div> <!-- col-md-9/col-md-12 -->


<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			<div class="widget">
    
	    <h4 class="dsq-widget-title">最新留言</h4>
		<div id="recent-comments"></div>
		<script type="text/javascript">
		    getRecentCommentsList({
			   type: "github" ? "github" : "github",
			   user: "zijiancogito",
               repo: "comment",
               client_id: "b79cbe842579a612ed08",
               client_secret: "6585bb42b7c5b2fedf088cfce6b7e811f8803fe3",
			   count: "5" ? "5" : 5,
			   recent_comments_target: "#recent-comments"
			});
		</script>
	
</div>

		
			
	<div class="widget">
		<h4>分类</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/骈文/最喜欢/">最喜欢<span>1</span></a></li>
		
			<li><a href="/categories/符号执行/">符号执行<span>1</span></a></li>
		
			<li><a href="/categories/编译/">编译<span>3</span></a></li>
		
			<li><a href="/categories/骈文/">骈文<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/Decompiliation/">Decompiliation<span>1</span></a></li>
		
			<li><a href="/tags/置顶/">置顶<span>1</span></a></li>
		
			<li><a href="/tags/Decompiler/">Decompiler<span>3</span></a></li>
		
			<li><a href="/tags/Symbolic-Execution/">Symbolic Execution<span>1</span></a></li>
		
			<li><a href="/tags/Binary-Analysis/">Binary Analysis<span>1</span></a></li>
		
			<li><a href="/tags/NN-Decompiler/">NN Decompiler<span>2</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2022/11/04/angr/" ><i class="fa fa-file-o"></i>angr</a>
      </li>
    
      <li>
        <a href="/2022/10/27/Symbolic-Execution-Tech/" ><i class="fa fa-file-o"></i>Symbolic Execution Tech</a>
      </li>
    
      <li>
        <a href="/2022/10/25/Decompiling-x86-Deep-Neural-Network-Executables/" ><i class="fa fa-file-o"></i>Decompiling x86 Deep Neural...</a>
      </li>
    
      <li>
        <a href="/2022/10/21/NeurDP/" ><i class="fa fa-file-o"></i>NeurDP</a>
      </li>
    
      <li>
        <a href="/2022/10/21/DnD-A-Cross-Architecture-Deep-Neural-Network-Decompiler/" ><i class="fa fa-file-o"></i>DnD: A Cross-Architecture D...</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/zijiancogito" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->




    </div>
  </div>
  <div class="container-narrow">
    <footer> <p>
  &copy; 2022 Zijian
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->

  <script>
  marked.setOptions({
    highlight: function (code, lang) {
        return hljs.highlightAuto(code).value;
    }
  });
  function Highlighting(){
    var markdowns = document.getElementsByClassName('markdown');
    for(var i=0;i<markdowns.length;i++){
        if(markdowns[i].innerHTML) markdowns[i].innerHTML =marked(markdowns[i].innerHTML);
    }
  }
  window.addEventListener('DOMContentLoaded', Highlighting, false);
  window.addEventListener('load', Highlighting, false);
  </script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


</body>
</html>